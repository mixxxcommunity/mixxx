#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import SCons
import shutil
import time
import SCons.Script as SCons

from build import util

mixxx_version = util.get_mixxx_version()
branch_name = util.get_bzr_branch_name()
bazaar_revision = util.get_bzr_revision()
print "WE ARE IN:", os.getcwd()

plugins = []

# Grab these from the SConstruct above us
Import('build')
Import('sources')
Import('soundsource_plugins')

env = build.env
flags = build.flags

#Tell SCons to build Mixxx
#=========================
if build.platform_is_windows:
	dist_dir = 'dist%s' % build.bitwidth
	mixxx_bin = env.Program('mixxx',
                            [sources, env.RES('#src/mixxx.rc')],
                            LINKCOM = [env['LINKCOM'], 'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;1'])
else:
	mixxx_bin = env.Program('mixxx', sources)

def build_tests():
        test_files = Glob('test/*.cpp', strings=True)
        test_env = env.Clone()
        test_env.Append(CPPPATH="#lib/gtest-1.5.0/include")
        test_env.Append(CPPPATH="#lib/gmock-1.5.0/include")
        test_files = [test_env.StaticObject(filename) \
                              if filename !='main.cpp' else filename
                      for filename in test_files]
        mixxx_sources = [filename for filename in sources if filename != 'main.cpp']
        test_sources = (test_files + mixxx_sources)

        env.Append(LIBPATH="#lib/gtest-1.5.0/lib")
	env.Append(LIBS = 'gtest')

        env.Append(LIBPATH="#lib/gmock-1.5.0/lib")
        env.Append(LIBS = 'gmock')

	env.Program(target='mixxx-test', source=test_sources)

	Command("../mixxx-test", "./mixxx-test", Copy("$TARGET", "$SOURCE"))

def run_tests():
        ret = Execute("./mixxx-test")
	if ret != 0:
                print "WARNING: Not all tests pass. See mixxx-test output."
                Exit(ret)

if int(build.flags['test']):
        print "Building tests."
        build_tests()

if 'test' in BUILD_TARGETS:
	print "Running tests."
	run_tests()

def osx_construct_version(build, mixxx_version, branch_name, bazaar_revision):
        # In release mode, we only use the version.
        if build.build_is_release:
                return mixxx_version
        # In a debug build, include the branch name and revision number
        return "%s-%s-bzr%s" % (mixxx_version, branch_name, bazaar_revision)

def ubuntu_construct_version(build, mixxx_version, branch_name, bazaar_revision,
                             ubuntu_version):
        # In release mode, we only use the version and ubuntu_version
	if build.build_is_release:
		return "%s-%s" % (mixxx_version, ubuntu_version)
	# In a debug build, include the branch name and revision number
	return "%s-%s~%s~bzr%s" % (mixxx_version, ubuntu_version,
                                   branch_name, bazaar_revision)

def windows_construct_version(build, mixxx_version, branch_name, bazaar_revision):
        # In release mode, we only use the version
	if build.build_is_release:
		return mixxx_version
	# In a debug build, include the branch name and revision number
	return "%s-%s-bzr%s" % (mixxx_version, branch_name, bazaar_revision)

#Set up the install target
#=========================
"""
flags['prefix'] = ARGUMENTS.get('prefix', '/usr/local')
if not os.path.exists(flags['prefix']):
	print "Error: Prefix path does not exist!"
	Exit(1)
else:
	unix_share_path = flags['prefix'] + "/share"
	unix_bin_path   = flags['prefix'] + "/bin"
"""

#Mixxx binary
binary_files = mixxx_bin;

# Mixxx essential resource files
resource_files = Glob('#res/schema.xml')

#Soundsource plugins
soundsource_plugin_files = soundsource_plugins

#Skins
skin_files = Glob('#res/skins/*')

#MIDI mappings
midimappings_files = Glob('#res/midi/*')

#Keyboard mapping(s)
keyboardmappings_files = Glob('#res/keyboard/*')

#Promo tracks
promotracks_files = Glob('#res/promo/*')

#LADSPA shizzle
ladspapresets_files = Glob('#res/ladspa_presets/*')

#Documentation
docs_files = Glob('#./LICENSE')
docs_files += Glob('#./README')
docs_files += Glob('#./Mixxx-Manual.pdf')

#.desktop file for KDE/GNOME menu
dotdesktop_files = Glob('#src/mixxx.desktop')

#Icon file for menu entry
icon_files = Glob('#res/images/mixxx-icon.png')

#Images for preferences dialog
image_files = Glob('#res/images/preferences/*')  # These are compiled in to the "mixxx" binary through mixxx.qrc

#Windows DLLs

# TODO: Use reference to SharedLibrary for libsndfile and others, glob only gets
# all files on 2+ builds after a clean.
if build.toolchain_is_msvs:
        mixxx_winlib_path = SCons.ARGUMENTS.get('winlib', '..\\..\\..\\mixxx-win32lib-msvc90-release')
        # skip the MSVC DLLs incase they're in there too
        dll_files = Glob('%s/[!"msvc"]*.dll' % mixxx_winlib_path)
elif build.crosscompile and build.platform_is_windows and build.toolchain_is_gnu:
        # We're cross-compiling, grab these from the crosscompile bin
        # folder. How should we be doing this?
        dll_files = Glob('#/../../mixxx-win%slib-crossmingw' % build.bitwidth)
elif build.crosscompile and build.platform_is_osx:
        # Glob appropriate dylib files. We have 4 different library types,
        # x86_64, x86, powerpc, powerpc64
        dylib_files = Glob('#/../../mixxx-osx-%s-crossmingw' % build.machine)
else:
        dll_files = list() # dll_files += on the next line required dll_files to exist

# dll_files = libsndfile
dll_files += Split("""$QTDIR/bin/QtCore4.dll $QTDIR/bin/QtGui4.dll $QTDIR/bin/QtNetwork4.dll $QTDIR/bin/QtOpenGL4.dll $QTDIR/bin/QtSql4.dll $QTDIR/bin/QtXml4.dll $QTDIR/bin/QtXmlPatterns4.dll $QTDIR/bin/QtSql4.dll $QTDIR/bin/QtSvg4.dll $QTDIR/bin/QtWebKit4.dll""")
if int(flags.get('sqlitedll', 0)):
	sqldll_files = Split("""$QTDIR/plugins/sqldrivers/qsqlite4.dll""") #Qt SQLite plugin

if int(flags['script']) or int(flags['midiscript']):
	dll_files += Split("""$QTDIR/bin/QtScript4.dll""")



if build.platform_is_linux or build.platform_is_bsd:
	flags['prefix'] = ARGUMENTS.get('prefix', '/usr/local')
	if not os.path.exists(flags['prefix']):
		print "Error: Prefix path does not exist!"
		Exit(1)
	else:
		#install_root is used in Debian/Ubuntu packaging (check the debian/rules file in the Ubuntu package)
		#Basically, the flags['prefix'] is compiled into strings in Mixxx, whereas the install_root is not. When you're
		#building a Debian package, pbuilder wants to install Mixxx to a temporary directory, but you still need
		#the compiled-in strings using /usr as the prefix. That's why we have install_root and flags['prefix'].
		install_root = ARGUMENTS.get('install_root', flags['prefix'])
		print "Install root: " + install_root
                unix_share_path = os.path.join(install_root, 'share')
                unix_bin_path = os.path.join(install_root, 'bin')
                unix_lib_path = os.path.join(install_root, 'lib')

		binary = env.Install(unix_bin_path, binary_files)
		resource = env.Install(os.path.join(unix_share_path, 'mixxx'), resource_files)
		skins = env.Install(os.path.join(unix_share_path, 'mixxx', 'skins'), skin_files)
		soundsource_plugins = env.Install(
                        os.path.join(unix_lib_path, 'mixxx', 'plugins', 'soundsource'),
                        soundsource_plugin_files)
		midimappings = env.Install(os.path.join(unix_share_path, 'mixxx', 'midi'), midimappings_files)
		keyboardmappings = env.Install(os.path.join(unix_share_path, 'mixxx', 'keyboard'), keyboardmappings_files)
		if int(flags['ladspa']):
			ladspapresets = env.Install(
                                os.path.join(unix_share_path, 'mixxx', 'ladspa_presets'), ladspapresets_files)
		dotdesktop = env.Install(os.path.join(unix_share_path, 'applications'), dotdesktop_files)
		docs = env.Install(os.path.join(unix_share_path, 'doc', 'mixxx'), docs_files)
		icon = env.Install(os.path.join(unix_share_path, 'pixmaps'), icon_files)
		promotracks = env.Install(os.path.join(unix_share_path, 'mixxx', 'promo'), promotracks_files)

		#Makes each of those Install builders get fired off when you run "scons install" :)
		env.Alias('install', binary)
		env.Alias('install', resource)
		env.Alias('install', skins)
		env.Alias('install', soundsource_plugins)
		env.Alias('install', midimappings)
		env.Alias('install', keyboardmappings)
		if int(flags['ladspa']):
			env.Alias('install', ladspapresets)
		env.Alias('install', docs)
		env.Alias('install', dotdesktop)
		env.Alias('install', icon)
		env.Alias('install', promotracks)

		#Delete the old Mixxx installation (because SCONS won't overwrite it)
		#if 'install' in COMMAND_LINE_TARGETS:
			#os.system('scons -c install')
			#Delete(unix_share_path + "/mixxx/skins")
			#print "Copying skins..."
			#env.Command(unix_share_path + "/mixxx/skins", skin_files, Copy("$TARGET", "$SOURCE"), source_scanner = DirScanner)
			#Copy(unix_share_path + "/.ixxx/skins", skin_files)
			#Delete(unix_bin_path + "mixxx")

			#Delete(unix_share_path + "/mixxx/midi")
			#Delete(unix_share_path + "/mixxx/keyboard")

#Build the Mixxx.app bundle
if build.platform_is_osx and 'bundle' in COMMAND_LINE_TARGETS:
	#Mixxx build variables
	VOLNAME="Mixxx" #tmp tmp tmp, it's unclean to pass this into build_dmg this way. perhaps pass it in the env?
        ARCH = 'ppc' if build.machine in ['powerpc', 'powerpc64'] else 'macintel'
        ARCH += ("64" if build.machine_is_64bit else "32")

	DMG_ICON="#res/osx/VolumeIcon.icns"

	# this is a BIG HACK to support Qt's plugins (since Qt *requires* that
	# it's plugins be in specific subdirectories, which OS X doesn't really
	# play nice with)
	qt_plugins = ([("iconengines", e) for e in ["libqsvgicon.dylib"]] +
                      [("imageformats", e) for e in ["libqgif.dylib", "libqjpeg.dylib", "libqsvg.dylib"]] +
                      [("sqldrivers", e) for e in ["libqsqlite.dylib"]] +
                      [("accessible", e) for e in ["libqtaccessiblecompatwidgets.dylib", "libqtaccessiblewidgets.dylib"]])
	#Left out libqmng and libqtiff to save space.

	# Concatenate the SoundSource plugins to our list of plugins (converting
	# from SCons File nodes to strings)
	for x in soundsource_plugins:
		plugins.append(x.get_abspath())

	bundle = env.App("Mixxx", [mixxx_bin, '#res/osx/application.icns',
		Dir('#res/skins/'),
		File('#res/schema.xml'),
		Dir('#res/midi/'), Dir('#res/keyboard/'),
		Dir('#res/ladspa_presets'), Dir('#res/doc/'), Dir('#res/promo/'),
        Dir('/Library/Frameworks/QtGui.framework/Resources/qt_menu.nib'),  #qt_menu.nib for Cocoa Qt 4.7+
        File("#README"), File("#LICENSE")],
		 PLUGINS=plugins, ##XXX test what happens if we don't pass any plugins
			#Qt plugins ((Qt *NEEDS* its plugins in specific locations or it refuses to find them, however this is clearly awkward to write out like this.. maybe))
		 QT_HACK = [(p_tgt_dir, os.path.join("/Developer/Applications/Qt/plugins/", p_tgt_dir, p)) for p_tgt_dir, p in qt_plugins] #sigh :(
		 ,
		 STRIP=build.build_is_release,
         IDENTIFIER="org.mixxx.mixxx",
         DISPLAY_NAME="Mixxx",
         SHORT_VERSION=mixxx_version, #FIXME: parse defs_version.h???
         COPYRIGHT="Copyright © 2011 Mixxx Development Team", #FIXME: datetime.year()
         CATEGORY="public.app-category.music"
		 )
	#env.Default(mixxx_bin) #todo: make the Default() just the program itself *globally* (not just for OS X); bundle should be a separate target
	env.Alias('bundle', bundle)

        package_name = 'mixxx'
	package_version = osx_construct_version(build, mixxx_version, branch_name, bazaar_revision)
        dmg_name = '%s-%s-%s' % (package_name, package_version, ARCH)
	dmg = env.Dmg(dmg_name, [bundle, ] + docs_files, VOLNAME=VOLNAME, ICON = DMG_ICON)
	env.Alias('package', dmg)

if build.platform_is_windows:
        base_dist_dir = '#' + dist_dir
	skins = env.Install(os.path.join(base_dist_dir, "skins"), skin_files)
	resource = env.Install(base_dist_dir+"/", resource_files)
	midimappings = env.Install(os.path.join(base_dist_dir, "midi"), midimappings_files)
	keyboardmappings = env.Install(os.path.join(base_dist_dir, "keyboard"), keyboardmappings_files)
	if int(flags['ladspa']):
		ladspapresets = env.Install(os.path.join(base_dist_dir, "ladspa_presets"), ladspapresets_files)
	docs = env.Install(os.path.join(base_dist_dir, "doc/"), docs_files)
	promotracks = env.Install(os.path.join(base_dist_dir, "promo/"), promotracks_files)
	#icon = env.Install(base_dist_dir+"", icon_files)
	dlls = env.Install(base_dist_dir+"/", dll_files)
	soundsource_plugins = env.Install(os.path.join(base_dist_dir, "plugins", "soundsource/"), soundsource_plugin_files)
	binary = env.Install(base_dist_dir+"/", binary_files)

	#Always trigger these install builders when compiling on Windows
	env.Alias('mixxx', skins)
	env.Alias('mixxx', resource)
	env.Alias('mixxx', midimappings)
	env.Alias('mixxx', keyboardmappings)
	if int(flags['ladspa']):
		env.Alias('mixxx', ladspapresets)
	env.Alias('mixxx', promotracks)
	env.Alias('mixxx', docs)
	env.Alias('mixxx', dlls)
	env.Alias('mixxx', soundsource_plugins)
	#env.Alias('mixxx', icon)
	env.Alias('mixxx', binary)

	# QSQLite DLL
	if 'sqldll_files' in locals():
		sql_dlls = env.Install(os.path.join(base_dist_dir, "sqldrivers"), sqldll_files)
		env.Alias('mixxx', sql_dlls)

def win32_find_nsis_via_registry():
    # Windows registry access to find where NSIS is installed
    import _winreg
    hklm = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)
    nsis_location_handle = None
    try:
        nsis_location_handle = _winreg.OpenKey(hklm, "SOFTWARE\\NSIS", 0, _winreg.KEY_READ)
    except WindowsError:
        nsis_location_handle = None

    if not nsis_location_handle:
        try:
            nsis_location_handle = _winreg.OpenKey(hklm, "SOFTWARE\\Wow6432Node\\NSIS", 0, _winreg.KEY_READ)
        except WindowsError:
            nsis_location_handle = None

    nsis_location = _winreg.QueryValue(nsis_location_handle, None)
    _winreg.CloseKey(hklm)
    return nsis_location

def BuildRelease(target, source, env):
    print
    print "==== Mixxx Post-Build Checks ===="
    print
    print "You have built version %s" % mixxx_version
    print
    if int(flags['msvcdebug']):
        print "YOU ARE ABOUT TO PACKAGE A DEBUG BUILD!!"
        print
    print "Binary has size ",
    if build.platform_is_windows:
        print "     Implement me!"
    else:
        os.system('ls -lh '+dist_dir+'/mixxx.exe | cut -d \' \' -f 5')
    print
    print "Installer file ",
    if build.platform_is_windows:
        print "     Implement me!"
    else:
        os.system('grep OutFile Mixxx.nsi | cut -d \' \' -f 2')
    print
    print "Top line of README, check version:"
    if build.platform_is_windows:
        print "     Implement me!"
    else:
        os.system('head -n 1 README')
    print
    print "Top 2 lines of LICENSE, check version and copyright dates:"
    if build.platform_is_windows:
        print "     Implement me!"
    else:
        os.system('head -n 2 LICENSE')

    #if (raw_input("Go ahead and build installer (yes/[no])? ") == "yes"):
    if True:
        print "\nNow building installer..."
        command_flag = None
        nsis_path = None
        if not build.crosscompile and build.platform_is_windows:
            nsis_directory = win32_find_nsis_via_registry()
            nsis_path = '"%s"' % os.path.join(nsis_directory, "makensis.exe")
            command_flag = '/'
        elif build.crosscompile and build.platform_is_windows:
            nsis_path = 'makensis'
            command_flag = '-'

        if not nsis_path:
            print "Cannot find NSIS. Do you have it installed?"
        else:
            package_name = 'mixxx'

            package_version = windows_construct_version(
                    build, mixxx_version, branch_name, bazaar_revision)
            arch = "x64" if build.machine_is_64bit else "x86"
            exe_name = '%s-%s-%s.exe' % (package_name, package_version, arch)

            # Call the NSIS build
            buildwin64 = "/Dx64=1" if build.machine_is_64bit else ''
            command = '%(path)s /DPACKAGE_NAME=%(package_name)s /DPRODUCT_VERSION=%(version)s /DWINLIB_PATH=%(winlibpath)s %(64bit)s build\\nsis\\Mixxx.nsi' % \
                {'path': nsis_path,
                 'package_name': exe_name,
                 'version': mixxx_version,
                 'winlibpath': mixxx_winlib_path,
                 '64bit': buildwin64}
            print "Using command:" + command
            os.system(command)
    else:
        print "Aborted building installer"

# Do release things
versionbld = Builder(action = BuildRelease, suffix = '.foo', src_suffix = '.bar')
env.Append(BUILDERS = {'BuildRelease' : versionbld})

if 'makerelease' in COMMAND_LINE_TARGETS:
	makerelease = env.BuildRelease('', binary_files)
	env.Alias('makerelease', makerelease)

def ubuntu_append_changelog(debian_dir,
			    package_name, package_version,
			    branch_name, bazaar_revision,
			    distro='karmic',
			    urgency='low'):
	now_formatted = time.strftime("%a,  %d %b %Y %H:%M:%S +0000", time.gmtime())
	new_entry = [
		"%s (%s) %s; urgency=%s" % (package_name, package_version, distro, urgency),
		"",
		"  * Experimental build of branch '%s' at Bazaar revision %s" % (branch_name,
                                                                                 bazaar_revision),
		"",
		" -- Mixxx Buildbot <builds@mixxx.org>  %s" % now_formatted,
		"",
		]
	lines = []
	with open(os.path.join(debian_dir, 'changelog'), 'r') as changelog:
		lines = list(changelog)
	with open(os.path.join(debian_dir, 'changelog'), 'w') as changelog:
		changelog.writelines(["%s\n" % x for x in new_entry])
		changelog.writelines(lines)

def ubuntu_cleanup():
	os.system('rm -rf ubuntu')
	os.mkdir('ubuntu')

# Build the Ubuntu package
def BuildUbuntuPackage(target, source, env):
	print
	print "==== Mixxx Post-Build Checks ===="
	print
	print "You have built version ", mixxx_version
	print
	print
	print "Top line of README, check version:"
	os.system('head -n 1 README')
	print
	print "Top 2 lines of LICENSE, check version and copyright dates:"
	os.system('head -n 2 LICENSE')
	print
	print "Top line of debian/ubuntu changelog, check version:"
	os.system('head -n 1 build/debian/changelog')
	print

	print "Now building DEB package..."
	print

	arch = 'amd64' if build.machine_is_64bit else 'i386'

        package_target = ARGUMENTS.get('package', None)
	ubuntu_distro = ARGUMENTS.get('ubuntu_dist', None)
	if ubuntu_distro is None:
		print "You did not specify an Ubuntu distribution to target. Specify one with the ubuntu_dist flag."
		# TODO(XXX) default to their current distro? the .pbuilderrc does this
		return
        ubuntu_version = ARGUMENTS.get('ubuntu_version', '0ubuntu1')

	# The underscore is super important here to make the deb package work
	package_name = 'mixxx'
	package_version = ubuntu_construct_version(build, mixxx_version,
                                                   branch_name, bazaar_revision,
                                                   ubuntu_version)

	#mixxx_dir = '%s-%s' % (package_name, mixxx_version)

        # directory and original tarball need to have the upstream-release
        # version, NOT the package version. For example:
        # upstream version: 1.10.0-beta1
        # package version: 1.10.0-beta1-0ubuntu1~bzr2206
        # directory name: mixxx-1.10.0-beta1
        # original tarball: mixxx_1.10.0-beta1.orig.tar.gz

	mixxx_dir = '%s-%s' % (package_name, mixxx_version)
	mixxx_tarball = "%s_%s.orig.tar.gz" % (package_name, mixxx_version)

	# Destroy ubuntu/ and create it
	ubuntu_cleanup()

	build_dir = os.path.join('ubuntu', mixxx_dir)

	if os.path.exists(build_dir):
		print "* Cleaning up %s (cwd: %s)" % (build_dir, os.getcwd())
		print
		os.system('rm -rf %s' % build_dir) # be careful.

	# TODO: make a get flags arg to accept a revision which can override this and checkout of a specific SVN rev for the package

	# Export the source folder
	print "* Exporting source folder from current workspace (bzr rev: %s)" % bazaar_revision
	print
	os.system('bzr export %s .' % build_dir)

	# Copy a patch to be included in the exported build sources (this can also be something like src/SConscript, /build/debian/rules)
	if os.path.exists('post-export-patch'):
		print "* Applying post export patch"
		print
		os.system('cp --dereference -r post-export-patch/* %s' % build_dir)

	os.chdir('ubuntu')

	# Tar the source code
	print "* Tarring source directory to '%s' ... (this can take a couple minutes)" % os.path.join(os.getcwd(), mixxx_tarball)
	print
	os.system('rm -f "%s"' % mixxx_tarball) #Remove old tarball
	os.system('tar --exclude=debian --exclude=debian/* -czf "%s" %s' % (mixxx_tarball, mixxx_dir))

	os.chdir(mixxx_dir)
	# Copy the debian folder from /build/debian to exported source folder root
	print "* Copying Debian build directory from build/debian to debian (cwd: %s)" % os.getcwd()
	print
	os.system('cp -r build/debian .')

	# Add a changelog record for this package
	if build.build_is_debug:
		ubuntu_append_changelog('debian', package_name, package_version,
                                        branch_name, bazaar_revision)

	# Run pbuilder
	print "* Starting pbuilder ...  (cwd: %s)" % os.getcwd()
	print

        command = ["ARCH=%s" % arch,
                   "DIST=%s" % ubuntu_distro]

        if package_target == 'source':
                # TODO(rryan) we have to figure out the key-signing situation
                # here.
                command.extend(['debuild', '-S', '-sa'])
        else:
                command.extend(['pdebuild'])
        result = os.system(' '.join(command))

	# Return back to the starting directory, otherwise you'll get a .sconsign.dblite error!
	os.chdir('../..')
	print "* Returning to starting working directory ...  (cwd: " + os.getcwd() + ")"
	print

        if package_target == 'source':
                if result == 0:
                        # TODO(rryan) check it actually succeeded
                        print "* Done! Signed source package is in ubuntu/"
                        print
                else:
                        print "* Build failed."
                        print
        else:
                result_path = "/var/cache/pbuilder/%s-%s/result/" % (ubuntu_distro, arch)
                result_filename = "%s_%s_%s.deb" % (package_name, package_version, arch)
                result_file = os.path.join(result_path, result_filename)
                dest_file = os.path.join('ubuntu', result_filename)

                if result == 0 and os.path.exists(result_file):
                        print "Done! Package and tarballs are in %s" % result_path
                        print "* Found package at '%s'. Copying to ubuntu/" % result_filename
                        print
                        shutil.copyfile(result_file, dest_file)
                else:
                        print "* Build failed."
                        print

	# print "Signing the .deb changes file..."
	# os.system('sudo debsign /var/cache/pbuilder/result/*.changes')

#Build the Ubuntu package if "makeubuntu" was passed as an argument
versiondebbld = Builder(action = BuildUbuntuPackage) #, suffix = '.foo', src_suffix = '.bar')
env.Append(BUILDERS = {'BuildUbuntuPackage' : versiondebbld})

if 'makeubuntu' in COMMAND_LINE_TARGETS:
	makeubuntu = env.BuildUbuntuPackage("blah", "defs_version.h" ) #(binary_files)
	env.Alias('makeubuntu', makeubuntu)
